var documenterSearchIndex = {"docs":
[{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/internals.jl\"","category":"page"},{"location":"generated/internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"AlgebraOfGraphics is based on contexts, which can be extended. Each context is then associated to a named tuple style (used for x, y axes or attributes in the plot) and a named tuple group used for grouping, forming a ContextualPair. A list of contextual pairs is called a contextual map.","category":"page"},{"location":"generated/internals/#Contexts-1","page":"Internals","title":"Contexts","text":"","category":"section"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"In the default context, all variables in style are broadcasted to a common shape, and each entry corresponds to a separate trace. The syntax dims exists to allow setting group variables that only vary with one of the dimensions. The group => style pairs corresponding to each group can be accessed with Base.pairs:","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"using RDatasets: dataset\nusing AlgebraOfGraphics\nd = style(:Cyl, :Hwy) * group(color = :Year)\npairs(d)","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"The DataContext is invoked with data(df), where df respects the Tables.jl interface. DefaultContexts can be merged onto a DataContext (column names are replaced by the corresponding arrays).","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"mpg = dataset(\"ggplot2\", \"mpg\")\nt = data(mpg)\npairs(t * d)","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"The slicing context is another example. It is invoked with dims(I::Int...), and signals along which dimension on the style to dims to extract series.","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"using AlgebraOfGraphics: dims\nctx = dims(1)\nx = rand(5, 3, 2)\ny = rand(5, 3)\npairs(dims(1) * style(x, y) * group(color=dims(2), marker=dims(3)))","category":"page"},{"location":"generated/internals/#Combining-operations-using-trees-1","page":"Internals","title":"Combining operations using trees","text":"","category":"section"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"All outputs of group, style, data, and dims inherit can be combined using + (adding a new layer), or * (merge information in existing layer).","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"using AbstractPlotting, CairoMakie, MakieLayout\nusing AlgebraOfGraphics: spec\nmpg1 = copy(mpg)\nmpg1.Displ = mpg.Displ .* 0.1\nts = (data(mpg) * spec(markersize = 5px) + data(mpg1) * spec(markersize=10px))\nsl = ts * style(:Hwy, :Displ) * group(color=:Cyl)","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"The result can then be plotted using the draw function:","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"using AlgebraOfGraphics: draw\nsl * spec(Scatter) |> draw\nAbstractPlotting.save(\"tree.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"(Image: )","category":"page"},{"location":"generated/internals/#Implementing-a-new-context-1","page":"Internals","title":"Implementing a new context","text":"","category":"section"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"To implement a new context, one can overload:","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"AlgebraOfGraphics.merge_group_style(c::ContextualPair{<:MyContext}, pd), to allow applying group and style to MyContext,\nBase.pairs(c::ContextualPair{<:MyContext}), which must iterates group::NamedTuple => style::NamedTuple pairs.","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"See example implementation in the context file.","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"generated/internals/#","page":"Internals","title":"Internals","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/JuliaPlots/AlgebraOfGraphics.jl/blob/master/docs/src/generated/tutorial.jl\"","category":"page"},{"location":"generated/tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Here we will see what are the basic building blocks of AlgebraOfGraphics, and how to combine them to create complex plots based on datas or other style formats.","category":"page"},{"location":"generated/tutorial/#Basic-building-blocks-1","page":"Tutorial","title":"Basic building blocks","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"The most important functions are group, style, and spec. style determines the mapping from data to plot. Its positional arguments correspond to the x, y or z axes of the plot, whereas the keyword arguments correspond to plot attributes that can vary continuously, such as color or markersize. group determines the grouping of the style. The style is split according to the variables listed in group, and then styled using a default palette. Finally spec can be used to give style-independent specifications about the plot (plotting function or attributes).","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"style, group, and spec work in various context. In the following we will explore DataContext, which is introduced doing data(df) for any tabular style structure df. In this context, style and group accept symbols and integers, which correspond to columns of the data.","category":"page"},{"location":"generated/tutorial/#Operations-1","page":"Tutorial","title":"Operations","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"The outputs of style, group, spec, and data can be combined with + or *, to generate a Layers object, which can then be plotted with a package that supports it (so far MakieLayout).","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"The operation + is used to create separate layer. a + b has as many layers as la + lb, where la and lb are the number of layers in a and b respectively.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"The operation a * b create la * lb layers, where la and lb are the number of layers in a and b respectively. Each layer of a * b contains the combined information of the corresponding layer in a and the corresponding layer in b. In simple cases, however, both a and b will only have one layer, and a * b simply combines the information.","category":"page"},{"location":"generated/tutorial/#Working-with-datas-1","page":"Tutorial","title":"Working with datas","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"using RDatasets: dataset\nusing AbstractPlotting, CairoMakie, MakieLayout\nusing AlgebraOfGraphics\nmpg = dataset(\"ggplot2\", \"mpg\");\ncols = style(:Displ, :Hwy);\ngrp = group(color = :Cyl);\nscat = spec(Scatter, markersize = 10px)\npipeline = cols * scat\ndata(mpg) * pipeline |> draw\nAbstractPlotting.save(\"scatter.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now let's simply add grp to the pipeline to do the grouping.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"data(mpg) * grp * pipeline |> draw\nAbstractPlotting.save(\"grouped_scatter.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: ) Traces can be added together with +.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"using AlgebraOfGraphics: linear\nlin = spec(linear, linewidth = 3)\npipenew = cols * (scat + lin)\ndata(mpg) * pipenew |> draw\nAbstractPlotting.save(\"linear.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: ) We can put grouping in the pipeline (we filter to avoid a degenerate group).","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"data(filter(row -> row.Cyl != 5, mpg)) * grp * pipenew |> draw\nAbstractPlotting.save(\"grouped_linear.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: ) This is a more complex example, where we split the scatter plot, but do the linear regression with all the style.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"different_grouping = grp * scat + lin\ndata(mpg) * cols * different_grouping |> draw\nAbstractPlotting.save(\"semi_grouped.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/#Non-tabular-style-1","page":"Tutorial","title":"Non tabular style","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"The framework is not specific to datas, but can be used with anything that the plotting package supports.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"x = [-pi..0, 0..pi]\ny = [sin cos] # We use broadcasting semantics on `tuple.(x, y)`.\nstyle(x, y) * group(color = dims(1), linestyle = dims(2)) * spec(linewidth = 3) |> draw\nAbstractPlotting.save(\"functions.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"import StatsMakie\nusing Distributions\nmus = 1:4\nshapes = [6, 10]\ngs = InverseGaussian.(mus, shapes')\ngeom = spec(linewidth = 3)\ngrp = group(color = dims(1), linestyle = dims(2))\nstyle(fill(0..5), gs) * grp * geom |> draw\nAbstractPlotting.save(\"distributions.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/#Layout-1","page":"Tutorial","title":"Layout","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"Thanks to the MakieLayout package it is possible to create plots where categorical variables inform the layout.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"iris = dataset(\"datasets\", \"iris\")\ncols = style([:SepalLength, :SepalWidth], [:PetalLength :PetalWidth])\ngrp = group(layout_x = dims(1), layout_y = dims(2), color = :Species)\ngeom = spec(Scatter, markersize = 10px) + spec(linear, linewidth = 3)\ndata(iris) * cols * grp * geom |> draw\nAbstractPlotting.save(\"layout.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/#Slicing-context-1","page":"Tutorial","title":"Slicing context","text":"","category":"section"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"The algebra of graphics logic can be easily extended to novel contexts. For example, dims implements the \"slices are series\" approach.","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"s = dims(1) * style(rand(50, 3), rand(50, 3, 2))\ngrp = group(color = dims(2), layout_x = dims(3))\ns * grp * spec(Scatter, markersize = 10px) |> draw\nAbstractPlotting.save(\"arrays.svg\", AbstractPlotting.current_scene()); nothing #hide","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"generated/tutorial/#","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"AlgebraOfGraphics defines a \"plotting package agnostic\" algebra of graphics based on a few simple building blocks that can be combined using + and *.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package is not yet released, but can be installed typing","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(@v1.4) pkg> add https://github.com/JuliaPlots/AlgebraOfGraphics.jl.git","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"in the Pkg REPL.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"See Tutorial for examples on how to use it. Devdocs are coming up next.","category":"page"}]
}
